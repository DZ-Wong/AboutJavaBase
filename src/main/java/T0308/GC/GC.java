package T0308.GC;

/**
 * Created by vip on 2018/3/22.
 */
public class GC {
    /*
    Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，
    减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；
    二是有了这块空间过后，如何进行分配和回收就跟GC机制有关了。

    java一般内存申请有两种：静态内存和动态内存。
    很容易理解，编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量；
    动态内存分配就是在程序执行时才知道要分配的存储空间大小，
    比如java对象的内存空间。根据上面我们知道，
    java栈、程序计数器、本地方法栈都是线程私有的，线程生就生，线程灭就灭，
    栈中的栈帧随着方法的结束也会撤销，内存自然就跟着回收了。
    所以这几个区域的内存分配与回收是确定的，我们不需要管的。
    但是java堆和方法区则不一样，我们只有在程序运行期间才知道会创建哪些对象
    ，所以这部分内存的分配和回收都是动态的。一般我们所说的垃圾回收也是针对的这一部分。

    Stack的内存管理是顺序分配的，而且定长，不存在内存回收问题；
    而Heap 则是为java对象的实例随机分配内存，不定长度，所以存在内存分配和回收的问题
    * */

    /**
     * 辣鸡收集器完成两件事：检测出来及； 回收垃圾。
     * 检测垃圾：方式
     * 1.引用计数法：给一个对象连接引用计数器，有地方引用它就加1 ，引用失效就减1；
     * （当对象A和B互相引用且都无法访问时，AB都是垃圾对象，但是引用计数不为0，所以有下面的）
     * 2。可达性分析算法：以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象
     本地方法中引用的对象等。
     */

    /**
     * 垃圾回收算法：方式
     * 1.标记-清除（Mark-sweep）：
     * 两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。
     * 缺点：效率低；标记清除之后会产生大量碎片
     * 2.复制（copying）：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。
     * 缺点：需要两倍内存空间
     * 3.标记-整理（Mark-Compact）：
     * 分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题
     *
     * 4.分代回收算法：
     * 同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
     * 年轻代：（Enden、survivor * 2）  复制算法
     * 年老代：标记-整理算法
     * 持久代：用于存放静态文件，比如java类、方法等。持久代对垃圾回收没有显著的影响
     *
     */


    /**
     * 什么时候？
     * 不能具体控制时间，系统在某时调用System.gc()；
     * （在堆上的分配）考虑到内存分配和回收机制：分代分配。分代回收。分为年轻代、年老代、永久代。年轻代分为Eden和两个survivor；
     * Eden（连续的空间）区满的时候，执行Minor GC，将存活的对象复制到survivor区；Survivor区满的时候，将其中存活的复制到Survivor2；切换15次之后，剩下的
     * 就复制到老年代。（Stop-and-copy）停止-复制清理法。（停止所有的线程执行）
     * Eden区，虚拟机用两种技术来加快内存分配。bump-the-pointer和TLAB(Thread-Local Allocation Buffers)
     * bump-the-pointer 跟踪最后一个对象，检查其后面是否有足够的内存分配新对象；
     * TLAB 多线程而言，将Eden分为若干段，结合btp技术，保证每个线程都使用Eden区的一段；
     *
     * 在老年代，内存空间大，GC次数少，内存不足时，执行Major GC，也叫Full GC。
     * 如果对象比较大，Young空间不足，大对象就会直接分配到老年代上，可以控制直接升入老年代的对象大小和进入老年代的年龄。
     * 使用标记-整理算法，
     * 在发生Minor GC时，如果进入老年代的大小大于老年代剩余内存，则触发FUll GC，否则看设置。
     *
     * 在方法区（永久代），回收两种：常量池中的常量（没有引用），无用的类信息。
     * 对无用的类进行回收,要保证：1.类实例都被回收；2.类加载器ClassLoader被回收；3.类对象的Class对象没有被引用（即没有通过反射引用该类的地方。
     *
     */

    /**
     * 对什么？
     * 对于超出作用域或引用计数为空的对象，从GC root（一组必须活跃的引用）开始搜索不到的对象，且经过一次标记-清理，后面没有复活的对象。
     */


    /**
     * 做了什么？
     * 删除不使用的对象，整理内存空间（分算法阐述），运行默认的finalize方法。
     *
     * 垃圾收集器----GC 的具体实现
     * Serial收集器 -- 使用停止复制算法，用一个线程进行GC，其他线程暂停
     *
     * ParNew收集器： --新生代收集器，Serial多线程版，用多个线程进行GC，其他工作线程暂停
     *
     * Parallel Scavenger收集器： --新生代收集器，停止复制算法， 关注CPU吞吐量，
     * 高效利用CPU，适合后台运算。
     *
     * Serial Old收集器： --老年代收集器，单线程---标记-整理（清理和压缩），其他线程暂停算法
     *
     * Parallel Old收集器： --老年代，多线程 -- 标记--整理（汇总和压缩），
     *
     * CMS收集器-- 老年代，致力于获取最短回收停顿时间，标记--清除，多线程，
     * 优点：并发收集，停顿小。
     * 两次初始标记（初始标记和并发标记）和重新标记，再一次清除。
     * 在老年代使用了2/3时触发Full GC。
     */

    /**
     * 并发 （concurrent）和并行（Parallel）
     * 并发：用户线程和GC线程同时执行，不需要停顿用户线程，（或者时间很短）
     * 并行：多个GC线程并行工作，此时用户线程暂停；
     *
     * Serial Paralle收集器是并行，CMS收集器是并发的。
     */
}
