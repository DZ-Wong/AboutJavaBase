package T0308.GC;

/**
 * Created by vip on 2018/3/22.
 */
public class GC {
    /*
    Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，
    减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；
    二是有了这块空间过后，如何进行分配和回收就跟GC机制有关了。

    java一般内存申请有两种：静态内存和动态内存。
    很容易理解，编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量；
    动态内存分配就是在程序执行时才知道要分配的存储空间大小，
    比如java对象的内存空间。根据上面我们知道，
    java栈、程序计数器、本地方法栈都是线程私有的，线程生就生，线程灭就灭，
    栈中的栈帧随着方法的结束也会撤销，内存自然就跟着回收了。
    所以这几个区域的内存分配与回收是确定的，我们不需要管的。
    但是java堆和方法区则不一样，我们只有在程序运行期间才知道会创建哪些对象
    ，所以这部分内存的分配和回收都是动态的。一般我们所说的垃圾回收也是针对的这一部分。

    Stack的内存管理是顺序分配的，而且定长，不存在内存回收问题；
    而Heap 则是为java对象的实例随机分配内存，不定长度，所以存在内存分配和回收的问题
    * */

    /**
     * 辣鸡收集器完成两件事：检测出来及； 回收垃圾。
     * 检测垃圾：方式
     * 1.引用计数法：给一个对象连接引用计数器，有地方引用它就加1 ，引用失效就减1；
     * （当对象A和B互相引用且都无法访问时，AB都是垃圾对象，但是引用计数不为0，所以有下面的）
     * 2。可达性分析算法：以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象
     本地方法中引用的对象等。
     */

    /**
     * 垃圾回收算法：方式
     * 1.标记-清除（Mark-sweep）：
     * 两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。
     * 缺点：效率低；标记清除之后会产生大量碎片
     * 2.复制（copying）：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。
     * 缺点：需要两倍内存空间
     * 3.标记-整理（Mark-Compact）：
     * 分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题
     *
     * 4.分代回收算法：
     * 同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
     * 年轻代：（Enden、survivor * 2）  复制算法
     * 年老代：标记-整理算法
     * 持久代：用于存放静态文件，比如java类、方法等。持久代对垃圾回收没有显著的影响
     * 
     */
}
